<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Лера Лера</title>
    <style>
        /* Basic page reset */
        body, html {
            margin: 0;
            padding: 0;
            background: #222;
            display: flex;
            flex-direction: column; /* Allow text above canvas */
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: #fff;
            font-family: 'Consolas', 'Courier New', monospace;
        }
        h1 {
            margin-bottom: 20px;
        }
        canvas {
            border: 2px solid #fff;
            background: #1e293b; /* A dark blue sky color */
        }
    </style>
</head>
<body>
    <h1>лера лера</h1>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <script>
// --- SETUP & CONSTANTS ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const tileSize = 40;

// Physics and Game Constants
const GRAVITY = 0.5;
const PLAYER_SPEED = 5;
const JUMP_FORCE = 12;

// --- GAME STATE ---
// NEW: A variable to control the game's state (intro, playing, gameOver)
let gameState = 'intro';

// --- LEVEL DATA & MANAGEMENT ---

const level1Data = [
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0],
    [0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],
    [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],
    [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2]
];

const level2Data = [
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0],
    [0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1],
    [1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,1,1,1,1,1],
    [1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],
    [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],
    [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],
    [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2]
];

const levels = [
    {
        map: level1Data,
        enemies: [ { x: 400, y: 300 }, { x: 900, y: 200 }, { x: 1200, y: 300 } ],
        collectibles: [ { x: 200, y: 200 }, { x: 650, y: 360 }, { x: 1100, y: 120 } ]
    },
    {
        map: level2Data,
        enemies: [ { x: 300, y: 400 }, { x: 700, y: 100 }, { x: 1000, y: 400 }, { x: 1400, y: 200 } ],
        collectibles: [ { x: 300, y: 160 }, { x: 500, y: 120 }, { x: 900, y: 280 }, { x: 1300, y: 360 } ]
    }
];

let currentLevelIndex = 0;
let currentMap;
let worldWidth;
let gameWon = false;

const player = { x: 100, y: 100, width: 42, height: 64, dx: 0, dy: 0, isOnGround: false, direction: 'right', health: 100, isAttacking: false, attackBox: { width: 40, height: 40 } };
let enemies = [];
function createEnemy(x, y) { enemies.push({ x, y, width: 64, height: 64, dx: 1, dy: 0, health: 50, patrolRange: 220, patrolStart: x }); }

let levelCollectibles = [];
let totalCollectiblesInLevel = 0;
const collectibleSize = { width: 42, height: 42 };

const camera = { x: 0, y: 0, width: canvas.width, height: canvas.height,
    update: function() {
        this.x = player.x - this.width / 2;
        if (this.x < 0) this.x = 0;
        if (this.x + this.width > worldWidth) this.x = worldWidth - this.width;
    }
};

const spritePaths = ['assets/girl1.png', 'assets/girl2.png', 'assets/hase.png', 'assets/beaurocrat.png'];
const playerWalkSprites = [];
let collectibleSprite;
let enemySprite;
let loadedImages = 0;
let frameIndex = 0, frameCounter = 0;
spritePaths.forEach((src) => {
    const img = new Image();
    img.onload = () => {
        loadedImages++;
        if (src.includes('girl')) playerWalkSprites.push(img);
        else if (src.includes('hase')) collectibleSprite = img;
        else if (src.includes('beaurocrat')) enemySprite = img;
        if (loadedImages === spritePaths.length) {
            loadLevel(0);
            requestAnimationFrame(gameLoop); // Start the loop once everything is ready
        }
    };
    img.onerror = () => console.error(`Failed to load sprite: ${src}`);
    img.src = src;
});

const keys = { ArrowUp: false, ArrowLeft: false, ArrowRight: false, ' ': false, 'x': false, 'X': false };
document.addEventListener('keydown', e => { if (keys.hasOwnProperty(e.key)) { e.preventDefault(); keys[e.key] = true; } });
document.addEventListener('keyup', e => { if (keys.hasOwnProperty(e.key)) { e.preventDefault(); keys[e.key] = false; } });

// CORRECTED: This version is more robust and handles edge cases better.
function getSafeCollectiblePosition(x, y) {
    let currentY = y;
    let checkX = x + collectibleSize.width / 2;

    let gridX = Math.floor(checkX / tileSize);
    let gridY = Math.floor((currentY + collectibleSize.height) / tileSize);

    // Eject upwards if starting inside a solid tile.
    while (gridY >= 0 && gridY < currentMap.length && currentMap[gridY][gridX] > 0) {
        currentY -= tileSize;
        gridY = Math.floor((currentY + collectibleSize.height) / tileSize);
    }

    // Drop down to find the ground.
    // Loop while the tile *below* the item's feet is empty.
    while (gridY + 1 < currentMap.length && currentMap[gridY + 1][gridX] === 0) {
        currentY += tileSize;
        gridY = Math.floor((currentY + collectibleSize.height) / tileSize);
    }

    // Final position is the top of the tile below, minus item height.
    const finalY = (gridY + 1) * tileSize - collectibleSize.height;
    return { x: x, y: finalY };
}

function loadLevel(levelIndex) {
    if (levelIndex >= levels.length) {
        gameWon = true;
        return;
    }
    currentLevelIndex = levelIndex;
    currentMap = levels[currentLevelIndex].map;
    worldWidth = currentMap[0].length * tileSize;
    player.x = 100;
    player.y = 100;
    player.dx = 0;
    player.dy = 0;
    enemies = [];
    levels[currentLevelIndex].enemies.forEach(e => {
        createEnemy(e.x, e.y);
    });
    levelCollectibles = [];
    levels[currentLevelIndex].collectibles.forEach(c => {
        const safePosition = getSafeCollectiblePosition(c.x, c.y);
        levelCollectibles.push({
            x: safePosition.x,
            y: safePosition.y,
            width: collectibleSize.width,
            height: collectibleSize.height
        });
    });
    totalCollectiblesInLevel = levelCollectibles.length;
}

// --- GAME LOGIC (UPDATE FUNCTION) ---
function update() {
    // This function only runs when gameState is 'playing'
    if (player.health <= 0) {
        gameState = 'gameOver';
        return;
    }
    if (gameWon) {
        gameState = 'gameWon';
        return;
    }

    // 1. Handle Player Input
    if (keys.ArrowLeft) { player.dx = -PLAYER_SPEED; player.direction = 'left'; }
    else if (keys.ArrowRight) { player.dx = PLAYER_SPEED; player.direction = 'right'; }
    else { player.dx = 0; }
    if ((keys.ArrowUp || keys[' ']) && player.isOnGround) { player.dy = -JUMP_FORCE; player.isOnGround = false; }
    if ((keys['x'] || keys['X']) && !player.isAttacking) { player.isAttacking = true; setTimeout(() => { player.isAttacking = false; }, 300); }

    // 2. Apply Physics
    player.dy += GRAVITY;
    player.x += player.dx;
    player.y += player.dy;
    player.isOnGround = false;

    // 3. Player vs. Level Collision
    for (let row = 0; row < currentMap.length; row++) {
        for (let col = 0; col < currentMap[row].length; col++) {
            if (currentMap[row][col] > 0) {
                const tile = { x: col * tileSize, y: row * tileSize, width: tileSize, height: tileSize };
                if (player.x < tile.x + tile.width && player.x + player.width > tile.x && player.y < tile.y + tile.height && player.y + player.height > tile.y) {
                    const prevOverlapY = (player.y - player.dy + player.height) - tile.y;
                    if (player.dy > 0 && prevOverlapY <= 0) { player.y = tile.y - player.height; player.dy = 0; player.isOnGround = true; }
                }
            }
        }
    }

    // 4. Update Enemies
    enemies.forEach(enemy => {
        enemy.dy += GRAVITY;
        enemy.y += enemy.dy;
        const groundY = Math.floor((enemy.y + enemy.height) / tileSize);
        const groundX = Math.floor((enemy.x + enemy.width / 2) / tileSize);
        if (currentMap[groundY] && currentMap[groundY][groundX] > 0) {
            enemy.y = groundY * tileSize - enemy.height;
            enemy.dy = 0;
            enemy.x += enemy.dx;
            if (enemy.x < enemy.patrolStart || enemy.x > enemy.patrolStart + enemy.patrolRange) { enemy.dx *= -1; }
        }
    });

    // 5. Combat and Enemy Collision
    if (player.isAttacking) {
        let attackX = player.direction === 'right' ? player.x + player.width : player.x - player.attackBox.width;
        enemies.forEach((enemy, index) => {
            if (attackX < enemy.x + enemy.width && attackX + player.attackBox.width > enemy.x && player.y < enemy.y + player.height && player.y + player.attackBox.height > enemy.y) {
                enemy.health -= 50;
                if (enemy.health <= 0) enemies.splice(index, 1);
            }
        });
    }
    enemies.forEach(enemy => {
        if (player.x < enemy.x + enemy.width && player.x + player.width > enemy.x && player.y < enemy.y + enemy.height && player.y + player.height > enemy.y) {
            player.health -= 1;
        }
    });

    // 6. Player vs. Collectible Collision
    for (let i = levelCollectibles.length - 1; i >= 0; i--) {
        const item = levelCollectibles[i];
        if (player.x < item.x + item.width && player.x + player.width > item.x && player.y < item.y + item.height && player.y + player.height > item.y) {
            levelCollectibles.splice(i, 1);
        }
    }

    // 7. Update Camera
    camera.update();

    // 8. Update Animation Frame
    if (player.dx !== 0 && player.isOnGround) {
        frameCounter++;
        if (frameCounter > 8) { frameIndex = (frameIndex + 1) % playerWalkSprites.length; frameCounter = 0; }
    } else { frameIndex = 0; }

    // 9. Check for Level Transition
    if (player.x > worldWidth && levelCollectibles.length === 0) {
        loadLevel(currentLevelIndex + 1);
    }
}

// --- RENDERING (DRAW FUNCTION) ---

// NEW: A dedicated function to draw the intro screen
function drawIntroScreen() {
    ctx.fillStyle = '#1e293b'; // Same as canvas background
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = 'white';
    ctx.textAlign = 'center';

    ctx.font = '50px Consolas';
    ctx.fillText('Лера Лера', canvas.width / 2, canvas.height / 2 - 120);

    ctx.font = '24px Consolas';
    ctx.fillText('Соберите всех кроликов, чтобы продвинуться вперед!', canvas.width / 2, canvas.height / 2 - 50);
    ctx.fillText('остерегайтесь немецких бюрократов!', canvas.width / 2, canvas.height / 2 - 30);
    ctx.font = '20px Consolas';
    ctx.fillText('Controls:', canvas.width / 2, canvas.height / 2 + 20);
    ctx.fillText('Arrow Keys = Move Left/Right', canvas.width / 2, canvas.height / 2 + 50);
    ctx.fillText('Space / Up Arrow = Jump', canvas.width / 2, canvas.height / 2 + 80);
    ctx.fillText('X = Attack', canvas.width / 2, canvas.height / 2 + 110);


    ctx.font = '30px Consolas';
    ctx.fillStyle = '#8bc34a'; // Green color for prompt
    ctx.fillText('Press SPACE to Start', canvas.width / 2, canvas.height / 2 + 180);
}


// MODIFIED: The main draw function now handles different game states.
function draw() {
    // If we're in the intro state, only draw that and nothing else.
    if (gameState === 'intro') {
        drawIntroScreen();
        return;
    }

    // --- Normal Game Drawing ---
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save();
    ctx.translate(-camera.x, -camera.y);

    // Draw level
    for (let y = 0; y < currentMap.length; y++) {
        for (let x = 0; x < currentMap[y].length; x++) {
            if (currentMap[y][x] > 0) {
                ctx.fillStyle = '#6d4c41';
                ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
                const isTopTile = (y === 0 || currentMap[y - 1][x] === 0);
                if (isTopTile) {
                    ctx.fillStyle = '#8bc34a';
                    ctx.fillRect(x * tileSize, y * tileSize, tileSize, 5);
                }
            }
        }
    }

    // Draw Collectibles
    if(collectibleSprite) {
        levelCollectibles.forEach(item => {
            ctx.drawImage(collectibleSprite, item.x, item.y, item.width, item.height);
        });
    }

    // Draw Enemies
    if(enemySprite) {
        enemies.forEach(enemy => {
            ctx.drawImage(enemySprite, enemy.x, enemy.y, enemy.width, enemy.height);
        });
    }

    // Draw player
    ctx.save();
    if (player.direction === 'left') { ctx.scale(-1, 1); ctx.translate(-player.x * 2 - player.width, 0); }
    if (playerWalkSprites[frameIndex]) { ctx.drawImage(playerWalkSprites[frameIndex], player.x, player.y, player.width, player.height); }
    ctx.restore();

    if (player.isAttacking) {
        ctx.fillStyle = 'rgba(255, 255, 0, 0.5)';
        let attackX = player.direction === 'right' ? player.x + player.width : player.x - player.attackBox.width;
        ctx.fillRect(attackX, player.y, player.attackBox.width, player.attackBox.height);
    }
    ctx.restore();

    // Draw UI
    ctx.fillStyle = 'red'; ctx.fillRect(10, 10, 200, 20);
    ctx.fillStyle = 'green'; ctx.fillRect(10, 10, player.health * 2, 20);
    ctx.strokeStyle = 'white'; ctx.strokeRect(10, 10, 200, 20);
    ctx.fillStyle = 'white'; ctx.font = '16px Consolas';
    ctx.fillText('HEALTH', 15, 26);
    ctx.fillText(`Level: ${currentLevelIndex + 1}`, 10, 50);
    const collectedCount = totalCollectiblesInLevel - levelCollectibles.length;
    ctx.fillText(`Items: ${collectedCount} / ${totalCollectiblesInLevel}`, 10, 70);

    // Win/Loss/Level Clear Messages
    ctx.font = '60px Consolas'; ctx.textAlign = 'center';
    if (gameState === 'gameOver') {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; ctx.fillRect(0,0, canvas.width, canvas.height);
        ctx.fillStyle = 'red'; ctx.fillText('You are Great, try again', canvas.width / 2, canvas.height / 2);
    } else if (gameState === 'gameWon') {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; ctx.fillRect(0,0, canvas.width, canvas.height);
        ctx.fillStyle = 'gold'; ctx.fillText('Ура! Tы получилa немецкий паспорт!', canvas.width / 2, canvas.height / 2);
    } else if (levelCollectibles.length === 0) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0,0, canvas.width, canvas.height);
        ctx.fillStyle = 'cyan';
        ctx.fillText('ALL ITEMS COLLECTED!', canvas.width / 2, canvas.height / 2);
        ctx.font = '20px Consolas';
        ctx.fillText('Proceed to the right exit...', canvas.width/2, canvas.height/2 + 40);
    }
}

// --- GAME LOOP ---
// MODIFIED: The loop now handles state transitions
function gameLoop() {
    // State logic comes first
    if (gameState === 'intro') {
        // If we are on the intro screen, check for the space key to start the game
        if (keys[' ']) {
            gameState = 'playing';
            keys[' '] = false; // Prevents the player from jumping immediately
        }
    } else if (gameState === 'playing') {
        update(); // Run the main game logic
    }

    // Drawing happens every frame, regardless of state
    draw();

    requestAnimationFrame(gameLoop);
}

// The game loop is started by the sprite loader when all images are ready.
    </script>
</body>
</html>